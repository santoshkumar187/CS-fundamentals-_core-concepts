1. CPU Scheduling
ğŸ§  Concept:

When multiple processes are ready to run, the OS decides which process gets the CPU next â€” this is CPU Scheduling.

ğŸ“š Common Scheduling Algorithms:
Algorithm	Description	Example
FCFS (First Come First Serve)	Runs in arrival order	Like a queue in a shop
SJF (Shortest Job First)	Runs shortest process first	Minimizes average waiting time
RR (Round Robin)	Each gets fixed time slice (quantum)	Used in time-sharing systems
Priority Scheduling	Based on priority number	High priority â†’ runs first
Multilevel Queue	Different queues for foreground/background	Advanced scheduling system
ğŸ§® Key Terms:

Burst Time â€“ Time required by a process for CPU.

Waiting Time â€“ Time spent waiting in ready queue.

Turnaround Time â€“ Total time from arrival to completion.

ğŸ“¦ 2. Process Synchronization
ğŸ§  Concept:

When multiple processes access shared data, synchronization prevents data inconsistency.

ğŸ’¡ Example Problem: Race Condition

Two threads modifying the same variable at the same time can cause incorrect results.

ğŸ§° Synchronization Tools:

Mutex (Mutual Exclusion)

Semaphore (Counting mechanism)

Monitors

Example (Semaphore):

wait(mutex);
   // critical section
signal(mutex);

ğŸ”’ 3. Deadlock
ğŸ§  Concept:

Deadlock occurs when processes are waiting for each otherâ€™s resources, and none can proceed.

Example:

Process A holds Resource 1, waiting for Resource 2

Process B holds Resource 2, waiting for Resource 1 â†’ Deadlock

ğŸ§­ Deadlock Conditions (Coffmanâ€™s):

Mutual Exclusion

Hold and Wait

No Preemption

Circular Wait

ğŸ§© Deadlock Handling Methods:
Method	Description
Prevention	Prevent one condition (e.g., circular wait)
Avoidance	Banker's Algorithm
Detection	Detect and recover
Ignore	Used in some systems (like Windows)
ğŸ’¾ 4. Memory Management
ğŸ§  Concept:

Manages how processes use main memory (RAM) efficiently.

ğŸ”‘ Concepts:

Logical vs Physical Address

Swapping â€“ Moving processes between main memory and disk

Paging â€“ Divide memory into fixed-size blocks (pages)

Segmentation â€“ Divide based on logical sections (code, data, stack)

ğŸ“Š Page Table:

Maps logical pages to physical frames.

Example:

Page	Frame
0	5
1	9
2




5. Virtual Memory
ğŸ§  Concept:

Allows processes to use more memory than physically available by using disk as extension of RAM.

Techniques:

Demand Paging â€“ Load pages only when needed

Page Replacement Algorithms:

FIFO (First In First Out)

LRU (Least Recently Used)

Optimal (Best but theoretical)

ğŸ“ 6. File Management
ğŸ§  Concept:

OS manages files and directories on secondary storage.

Operations:

Create, Delete, Read, Write, Move, Rename

File Attributes: name, type, size, permissions

Directory Structures:

Single-level

Two-level

Tree-structured

Acyclic graph

ğŸ“€ 7. Disk Scheduling
ğŸ§  Concept:

Manages the order of disk I/O requests to minimize seek time.

Algorithms:
Algorithm	Description
FCFS	Serve in order of arrival
SSTF	Shortest Seek Time First
SCAN	Moves like elevator (back & forth)
C-SCAN	Circular SCAN (only one direction)
ğŸ” 8. Security & Protection
ğŸ§  Concept:

OS ensures data is protected against unauthorized access.

Methods:

Authentication (passwords, biometrics)

Authorization (access control)

Encryption

ğŸ§  9. System Calls & Kernel Types
Kernel Type	Description
Monolithic Kernel	All OS services in one layer
Microkernel	Minimal kernel + services in user space
Hybrid	Combination (used in Windows, macOS)
