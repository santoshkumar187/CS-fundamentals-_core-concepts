🔒 What is a Deadlock?
A deadlock occurs in multithreaded programming when two or more threads are blocked forever, each waiting for the other to release a resource. It typically happens when:

Multiple threads hold locks.

Each thread waits for a lock held by another.

None of them can proceed.

☕ Java Deadlock Example
Here’s a simple Java program that demonstrates deadlock using two threads and two locks:

java
public class DeadlockExample {
    static final Object Lock1 = new Object();
    static final Object Lock2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (Lock1) {
                System.out.println("Thread 1: Holding Lock1...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                System.out.println("Thread 1: Waiting for Lock2...");
                synchronized (Lock2) {
                    System.out.println("Thread 1: Acquired Lock2!");
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (Lock2) {
                System.out.println("Thread 2: Holding Lock2...");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                System.out.println("Thread 2: Waiting for Lock1...");
                synchronized (Lock1) {
                    System.out.println("Thread 2: Acquired Lock1!");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
🧠 What Happens Here:
Thread 1 locks Lock1 and waits for Lock2.

Thread 2 locks Lock2 and waits for Lock1.

Both threads are stuck waiting for each other — deadlock!

🛠️ How to Prevent Deadlock
Always acquire locks in a consistent order.

Use timeout mechanisms.

Avoid nested locks when possible.

**************************************************************


  🔐 What is Hashing?
Hashing is a technique used to map data of arbitrary size to fixed-size values (called hash codes or hash values). It’s commonly used for:

Fast data retrieval

Data integrity checks

Cryptography

Implementing hash tables

A hash function takes input (like a string or number) and returns a fixed-size output (usually an integer).

🧠 Why Use Hashing?
Efficiency: Access time is typically O(1) in hash tables.

Security: Hashing is used in password storage and digital signatures.

Data Integrity: Hashes help detect changes in data (e.g., file checksums).

☕ Java Hashing Example (Using HashMap)
java
import java.util.HashMap;

public class HashingExample {
    public static void main(String[] args) {
        HashMap<String, Integer> scores = new HashMap<>();

        // Insert key-value pairs
        scores.put("Alice", 90);
        scores.put("Bob", 85);
        scores.put("Charlie", 92);

        // Retrieve value by key
        System.out.println("Bob's score: " + scores.get("Bob"));  // Output: 85

        // Check if key exists
        if (scores.containsKey("Alice")) {
            System.out.println("Alice is in the map.");
        }
    }
}
🔍 What’s Happening Behind the Scenes:
HashMap uses a hash function to convert keys (like "Bob") into an index.

That index points to a bucket where the value (85) is stored.

If multiple keys hash to the same index, Java handles it using chaining or open addressing.
